def merge_intervals(intervals):
    # If the input list is empty, return an empty list
    if not intervals:
        return []
    
    # Step 1: Sort the intervals by their starting times
    intervals.sort(key=lambda x: x[0])
    
    # Step 2: Initialize a list to hold merged intervals
    merged = [intervals[0]]  # Start with the first interval
    
    # Step 3: Iterate through the sorted intervals
    for i in range(1, len(intervals)):
        current_interval = intervals[i]
        last_merged_interval = merged[-1]
        
        # If the current interval overlaps with the last merged one
        if current_interval[0] <= last_merged_interval[1]:
            # Merge them by updating the end of the last merged interval
            last_merged_interval[1] = max(last_merged_interval[1], current_interval[1])
        else:
            # No overlap, so add the current interval to the merged list
            merged.append(current_interval)
    
    return merged

# Example test case
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge_intervals(intervals))  # Output: [[1, 6], [8, 10], [15, 18]]



def merge_intervals(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]  
    for i in range(1, len(intervals)):
        current_interval = intervals[i]
        last_merged_interval = merged[-1]
        if current_interval[0] <= last_merged_interval[1]:
            last_merged_interval[1] = max(last_merged_interval[1], current_interval[1])
        else:
            merged.append(current_interval)
    return merged


intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge_intervals(intervals))  
